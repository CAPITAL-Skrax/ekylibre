- if @started_at && @stopped_at
  :ruby
    series = []
    categories = {}
    date = @started_at
    while date < @stopped_at
      categories[date.year.to_s + date.month.to_s.rjust(3, '0')] = date.l(format: "%b %Y")
      date = date >> 1
    end

    # data for bar chart revenues by product_nature and by month
    #ProductNature.availables.find_each do |nature|
    #  sale_items = SaleItem.of_product_nature(nature).between(@started_at, @stopped_at)
    #  if sale_items.count > 0
    #    item_h = sale_items.sums_of_periods.sort.inject({}) do |hash, pair|
    #      hash[pair.expr.to_i.to_s] = pair.sum.to_d
    #      hash
    #    end
    #    series << {type: 'column', name: nature.name, data: normalize_serie(item_h, categories.keys) }
    #  end
    #end

    # data for bar chart draft revenues by product_nature and by month
    #ProductNature.availables.find_each do |nature|
    #  sale_items = SaleItem.of_product_nature(nature).estimate_between(@started_at, @stopped_at)
    #  if sale_items.count > 0
    #    item_h = sale_items.sums_of_periods( period: :month, column: :pretax_amount, at: "accounted_at",name: :sum).sort.inject({}) do |hash, pair|
    #      hash[pair.expr.to_i.to_s] = pair.sum.to_d
    #      hash
    #   end
    #    series << {type: 'column', name: nature.name, data: normalize_serie(item_h, categories.keys) }
    #  end
    #end

    # data for spline sum revenues by month
    all_sale_items = SaleItem.between(@started_at, @stopped_at)
    item_h = all_sale_items.sums_of_periods.sort.inject({}) do |hash, pair|
      hash[pair.expr.to_i.to_s] = pair.sum.to_d
      hash
    end
    series << {type: 'spline', name: :total_sales.tl, data: normalize_serie(item_h, categories.keys), marker: { line_width: 2 }}

    # data for spline sum expenses by month
    all_purchase_items = PurchaseItem.between(@started_at, @stopped_at)
    item_h = all_purchase_items.sums_of_periods.sort.inject({}) do |hash, pair|
      hash[pair.expr.to_i.to_s] = pair.sum.to_d
      hash
    end
    series << { type: 'spline', name: :total_purchases.tl, data: normalize_serie(item_h, categories.keys), marker: { line_width: 2 }}

    # data for incoming_payment by month
    all_incoming_payments_items = IncomingPayment.between(@started_at, @stopped_at)
    item_h = all_incoming_payments_items.sums_of_periods.sort.inject({}) do |hash, pair|
      hash[pair.expr.to_i.to_s] = pair.sum.to_d
      hash
    end
    series << { type: 'spline', name: :incoming_payment_duty_free.tl, data: normalize_serie(item_h, categories.keys), marker: { line_width: 2 }}

    # Data for outgoing_payments by month
    all_outgoing_payments_items = OutgoingPayment.between(@started_at, @stopped_at)
    item_h = all_outgoing_payments_items.sums_of_periods.sort.inject({}) do |hash, pair|
      hash[pair.expr.to_i.to_s] = pair.sum.to_d
      hash
    end
    series << { type: 'spline', name: :outgoing_payment_duty_free.tl, data: normalize_serie(item_h, categories.keys), marker: { line_width: 2 }}


    # data for pie revenues by product_nature
    data = []
    sale_items_pretax_amount = all_sale_items.sum(:pretax_amount)
    data << { name: :total_sales.tl, y: sale_items_pretax_amount.to_s.to_f }
    purchases_items_pretax_amount = all_purchase_items.sum(:pretax_amount)
    data << { name: :total_purchases.tl, y: purchases_items_pretax_amount.to_s.to_f }
    incoming_payment_amount = all_incoming_payments_items.sum(:amount)
    data << { name: :incoming_payment_duty_free.tl, y: incoming_payment_amount.to_s.to_f }
    outgoing_payment_amount = all_outgoing_payments_items.sum(:amount)
    data << { name: :outgoing_payment_duty_free.tl, y: outgoing_payment_amount.to_s.to_f }

    unless purchases_items_pretax_amount.zero? && sale_items_pretax_amount.zero?
      series << { type: 'pie', name: :total.tl, data: data, center: [50, 50], size: 100, show_in_legend: false, data_labels: { enabled: false }}
    end
  = column_highcharts(series, y_axis: { title: { text: :pretax_amount.tl }}, x_axis: { categories: categories.values }, legend: true)

- else
  = no_data
